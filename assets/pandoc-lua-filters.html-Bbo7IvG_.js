import{_ as r,c as t,a as e,b as s,t as d,e as a,d as p,w as o,r as c,o as u}from"./app-3vC-laG6.js";const m={},b={id:"frontmatter-title",tabindex:"-1"},v={class:"header-anchor",href:"#frontmatter-title"};function g(i,n){const l=c("RouteLink");return u(),t("div",null,[e("h1",b,[e("a",v,[e("span",null,d(i.$frontmatter.title),1)])]),n[5]||(n[5]=s(`<p>Pandoc поддерживает большое количество форматов разметки, как для входных данных, так и для выхода. Конвертация основана на том, что входные данные преобразуются в определённое внутреннее представление, а результат получается переводом из внутреннего представления в выходной формат.</p><p>Внутренний формат — <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE" target="_blank" rel="noopener noreferrer">абстрактное синтаксическое дерево</a>. Чтобы увидеть его в виде JSON используете следующую команду:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">pandoc -o book.json book.md</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,3)),e("p",null,[n[1]||(n[1]=a("Pandoc позволяет внести изменения в AST с помощью фильтров. Таким способом можно добиться поддержки своего формата, такого как ")),p(l,{to:"/format-comtext.html"},{default:o(()=>n[0]||(n[0]=[a("Comtext")])),_:1}),n[2]||(n[2]=a(". Фильтры можно писать на разных языка программирования, однако, фильтры на ")),n[3]||(n[3]=e("a",{href:"https://www.lua.org/",target:"_blank",rel:"noopener noreferrer"},"Lua",-1)),n[4]||(n[4]=a(" выделяются тем, что не требуют дополнительных программ, так как интерпретатор Lua встроен в Pandoc."))]),n[6]||(n[6]=s(`<p>Следующий фильтр удаляет из AST разметку номеров страниц в формате Comtext.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">local text = pandoc.text</span>
<span class="line"></span>
<span class="line">local function is_page_number(page_number_start, space, page_number_end)</span>
<span class="line">  return page_number_start and page_number_start.t == &#39;Str&#39;</span>
<span class="line">    and page_number_end and page_number_end.t == &#39;Str&#39;</span>
<span class="line">    and space and space.t == &#39;Space&#39;</span>
<span class="line">    and page_number_start.text == &#39;[#&#39;</span>
<span class="line">    and page_number_end.text:sub(-1) == &#39;]&#39;</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">local function is_inline_page_number(page_number_start, space, page_number_end)</span>
<span class="line">  return page_number_start and page_number_start.t == &#39;Str&#39;</span>
<span class="line">    and page_number_end and page_number_end.t == &#39;Str&#39;</span>
<span class="line">    and space and space.t == &#39;Space&#39;</span>
<span class="line">    and page_number_start.text:sub(-2) == &#39;[#&#39;</span>
<span class="line">    --and page_number_end.text:sub(-1) == &#39;]&#39;</span>
<span class="line">end</span>
<span class="line"></span>
<span class="line">function Inlines (inlines)</span>
<span class="line">  -- Go from end to start to avoid problems with shifting indices.</span>
<span class="line">  for i = #inlines-2, 1, -1 do</span>
<span class="line">    if is_page_number(inlines[i], inlines[i+1], inlines[i+2]) then</span>
<span class="line">      inlines:remove(i+2)</span>
<span class="line">      inlines:remove(i+1)</span>
<span class="line">      inlines:remove(i)</span>
<span class="line">    elseif is_inline_page_number(inlines[i], inlines[i+1], inlines[i+2]) then </span>
<span class="line">      inlines[i].text = inlines[i].text:sub(1, -3)</span>
<span class="line">      inlines[i+2].text = inlines[i+2].text:gsub(&#39;(.-])&#39;, &#39;&#39;)</span>
<span class="line"></span>
<span class="line">      inlines:remove(i+1)</span>
<span class="line">    end</span>
<span class="line">  end</span>
<span class="line">  return inlines</span>
<span class="line">end</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>В Lua-фильтрах каждая глобальная функция сравнивается с названием названиями типов элементов синтаксического дерева. Если есть совпадающие то они вызываются для всех элементов этого типа. Если функция возвращает <code>nil</code>, то элемент остаётся без изменения. Если функция возвращает новый элемент, то этот элемент обновляется в исходном дереве.</p><p>В примере выше, функция <code>Inlines</code> вызывается для всех абзацев и содержит в себе коллекцию со словами внутри абзаца. Во время последовательного перебора элементов происходит поиск тега <code>[# номер_страницы]</code> и если такой обнаруживается, то эти элементы удаляются. Особый случай представляет собой разрыв страницы на середине слова.</p><h2 id="ссылки" tabindex="-1"><a class="header-anchor" href="#ссылки"><span>Ссылки</span></a></h2><ul><li><a href="https://github.com/comtextspace/pandoc-filter-comtext" target="_blank" rel="noopener noreferrer">Репозиторий с фильтрами для Comtext</a>.</li><li><a href="https://learnxinyminutes.com/docs/lua/" target="_blank" rel="noopener noreferrer">Learn Lua in Y minutes</a></li><li><a href="https://github.com/jgm/pandoc/wiki/Pandoc-Filters" target="_blank" rel="noopener noreferrer">Pandoc Filters Wiki</a></li><li><a href="https://pandoc.org/filters.html" target="_blank" rel="noopener noreferrer">Pandoc Documentation. Pandoc filters</a></li><li><a href="https://pandoc.org/lua-filters.html" target="_blank" rel="noopener noreferrer">Pandoc Documentation. Pandoc Lua Filters</a></li><li><a href="https://pandoc.org/custom-readers.html" target="_blank" rel="noopener noreferrer">Pandoc Documentation. Creating Custom Pandoc Readers in Lua</a></li></ul>`,6))])}const f=r(m,[["render",g]]),h=JSON.parse('{"path":"/pandoc-lua-filters.html","title":"Lua-фильтры в Pandoc","lang":"ru-RU","frontmatter":{"title":"Lua-фильтры в Pandoc","date":"2023-11-03","categories":["Программы"],"tags":["pandoc"]},"git":{"updatedTime":1699109307000,"contributors":[{"name":"Petro","username":"Petro","email":"petrovdrm86@yandex.ru","commits":2,"url":"https://github.com/Petro"}],"changelog":[{"hash":"f1c5652042914343a73a4d5841cd0132d4053bcb","time":1699109307000,"email":"petrovdrm86@yandex.ru","author":"Petro","message":"add post about pandoc lua filters"},{"hash":"63c607dbbcd5968a2b6d909a6953087c57b0ad57","time":1699086027000,"email":"petrovdrm86@yandex.ru","author":"Petro","message":"Исправление опечаток"}]},"filePathRelative":"pandoc-lua-filters.md"}');export{f as comp,h as data};
